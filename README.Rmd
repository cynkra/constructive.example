---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# constructive.example

This package serves as an example on how to extend {constructive}.

## Implement a constructor for a new class

Let's add support for a new class : "qr". This is the class of the object we get
after applying `base::qr()` to get the QR decomposition of a matrix.

The reconstruction of qr objects is not perfect due to rounding errors so the 
feature is not a good fit for {constructive} but is a good use case for an example.

First note that {constructive} works even if it doesn't support directly a class,
it will then use the next relevant constructor:

```{r, error = TRUE}
library(constructive)

# will work but use the list constructor
A <- matrix(1:6, nrow = 3)
qr_A <- qr(A)
construct(qr_A)
```

We used the following workflow:

* Call `constructive::.cstr_new_class(class = "qr", constructor = "qr")`
* Save the script and call `devtools::document()` (see [this commit](https://github.com/cynkra/constructive.example/commit/3aeb429f00dafa458575e194e0f35ce8eb05ca2d#diff-f74f3e31638afda340efd3e55979a30b9a1ba431fbd6ccceaff0f1711ef45ef4)).
* Update the code (see [this commit](https://github.com/cynkra/constructive.example/commit/ba11788e65f2ff5df37ef6dd0941c65245212089))
* `devtools::load_all()`

After this we have:

```{r, error = TRUE}
library(constructive.example)
construct(qr_A)
```

The recreation was not perfect due to rounding errors but we're pretty close

```{r, error = TRUE}
construct_issues()
```

We still get the previous behavior if we use the `"next"` constructor.

```{r}
# fall back on the next method, which is for lists
construct(qr_A, opts_qr("next"))
```

Thanks to our implementation of `is_corrupted_qr()` we don't fail on corrupted objects
but fall back to the next method.

```{r}
corrupted <- structure(1:3, class = "qr")
construct(corrupted)
```

## Implement a new constructor for a supported class

We build a new constructor for the class "tbl_df" (tibbles), using the deprecated
constructor `tibble::data_frame()`, equivalent to `tibble::tibble()`. 

We used the following workflow:

* Call `constructive::.cstr_new_constructor(class = c("tbl_df", "tbl", "data.frame"), constructor = "tibble::data_frame")`
* Save the script and call `devtools::document()`, see [this commit](https://github.com/cynkra/constructive.example/commit/3aeb429f00dafa458575e194e0f35ce8eb05ca2d#diff-f74f3e31638afda340efd3e55979a30b9a1ba431fbd6ccceaff0f1711ef45ef4)
* Update the code (see [this commit](https://github.com/cynkra/constructive.example/commit/ba11788e65f2ff5df37ef6dd0941c65245212089))
* `devtools::load_all()`

After this we have:

```{r}
construct(dplyr::band_members, opts_tbl_df("data_frame"))
```

Note that [our implementation of the "tibble" constructor in {constructive}](https://github.com/cynkra/constructive/blob/86d8d3d47081e17a691cde1188c838c80b072e56/R/s3-tbl_df.R#L54)
is more sophisticated because `tibble()` cannot create columns named `.rows` or `.name_repair`,
and we check if the object is corrupted.
